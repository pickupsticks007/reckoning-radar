<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Connections — Reckoning Radar</title>
<link rel="preconnect" href="https://fonts.googleapis.com">
<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
<link href="https://fonts.googleapis.com/css2?family=DM+Mono:ital,wght@0,300;0,400;0,500;1,300;1,400&family=Source+Sans+3:ital,wght@0,300;0,400;0,600;1,300;1,400&display=swap" rel="stylesheet">
<link rel="stylesheet" href="https://use.typekit.net/ycq7lwb.css">
<script src="https://cdn.jsdelivr.net/npm/@supabase/supabase-js@2"></script>

<style>
  :root {
    --bg:            #F7F4EF;
    --bg-secondary:  #EDE9E1;
    --bg-card:       #FAFAF7;
    --border:        rgba(0,0,0,0.07);
    --border-mid:    rgba(0,0,0,0.12);
    --border-strong: rgba(0,0,0,0.22);
    --text-primary:  #0D0D0D;
    --text-secondary:#4A4A4A;
    --text-tertiary: #888888;
    --accent:        #1A1A1A;
    --accent-bg:     rgba(26,26,26,0.06);
    --node-bg:       #1A1A1A;
    --node-text:     #F7F4EF;
    --edge-color:    rgba(26,26,26,0.15);
    --edge-active:   rgba(26,26,26,0.35);
    --highlight:     #C8102E;
    --highlight-dim: rgba(200,16,46,0.08);
    --highlight-mid: rgba(200,16,46,0.2);
  }
  [data-theme="dark"] {
    --bg:            #111111;
    --bg-secondary:  #0A0A0A;
    --bg-card:       #161616;
    --border:        rgba(255,255,255,0.07);
    --border-mid:    rgba(255,255,255,0.11);
    --border-strong: rgba(255,255,255,0.22);
    --text-primary:  #F0EDE8;
    --text-secondary:#9A9590;
    --text-tertiary: #555550;
    --accent:        #FFED29;
    --accent-bg:     rgba(255,237,41,0.06);
    --node-bg:       #F0EDE8;
    --node-text:     #111111;
    --edge-color:    rgba(240,237,232,0.1);
    --edge-active:   rgba(240,237,232,0.25);
    --highlight:     #FF4060;
    --highlight-dim: rgba(255,64,96,0.08);
    --highlight-mid: rgba(255,64,96,0.2);
  }

  * { box-sizing: border-box; margin: 0; padding: 0; }

  body {
    font-family: 'Source Sans 3', sans-serif;
    background: var(--bg);
    color: var(--text-primary);
    min-height: 100vh;
    transition: background 0.3s, color 0.3s;
  }

  /* NAV */
  .site-nav {
    display: flex; align-items: center; justify-content: space-between;
    padding: 0 1.5rem; height: 52px;
    background: var(--bg); border-bottom: 1px solid var(--border-mid);
    position: sticky; top: 0; z-index: 100;
  }
  .topbar-logo-link { text-decoration: none; flex-shrink: 0; }
  .topbar-logo {
    display: flex; flex-direction: column;
    align-items: flex-start; line-height: 1; gap: 1px;
  }
  .logo-the {
    font-family: 'neue-haas-grotesk-display', sans-serif;
    font-weight: 300; font-size: 0.52rem; letter-spacing: 0.25em;
    text-transform: uppercase; color: var(--text-tertiary);
  }
  .logo-main {
    font-family: 'neue-haas-grotesk-display', sans-serif;
    font-weight: 700; font-size: 1.15rem; letter-spacing: -0.02em;
    color: var(--text-primary); white-space: nowrap;
  }
  .nav-links { display: flex; align-items: center; gap: 0.25rem; }
  .nav-link {
    font-family: 'Montserrat', sans-serif; font-size: 0.68rem;
    font-weight: 600; letter-spacing: 0.06em; text-transform: uppercase;
    color: var(--text-tertiary); text-decoration: none;
    padding: 0.3rem 0.7rem; border-radius: 3px;
    transition: color 0.15s, background 0.15s;
  }
  .nav-link:hover { color: var(--text-primary); background: var(--border); }
  .nav-link.active { color: var(--text-primary); }
  .theme-toggle {
    background: none; border: 1px solid var(--border-mid);
    color: var(--text-tertiary); width: 28px; height: 28px;
    border-radius: 50%; cursor: pointer; font-size: 0.75rem;
    display: flex; align-items: center; justify-content: center;
    transition: all 0.15s; margin-left: 0.5rem;
  }
  .theme-toggle:hover { color: var(--text-primary); border-color: var(--border-strong); }

  /* PAGE LAYOUT */
  .page-wrap {
    max-width: 860px;
    margin: 0 auto;
    padding: 3rem 2rem 5rem;
  }

  /* HEADER */
  .page-title {
    font-family: 'neue-haas-grotesk-display', sans-serif;
    font-weight: 500; font-size: clamp(1.8rem, 4vw, 2.8rem);
    letter-spacing: -0.02em; line-height: 1.1;
    margin-bottom: 0.75rem;
  }
  .page-subtitle {
    font-size: 1rem; line-height: 1.6;
    color: var(--text-secondary); max-width: 520px;
    margin-bottom: 2.5rem;
  }

  /* SEARCH PANEL */
  .search-panel {
    display: grid;
    grid-template-columns: 1fr auto 1fr;
    align-items: end;
    gap: 1rem;
    background: var(--bg-card);
    border: 1px solid var(--border-mid);
    border-radius: 6px;
    padding: 1.5rem;
    margin-bottom: 1rem;
  }
  .search-field { display: flex; flex-direction: column; gap: 0.4rem; }
  .search-label {
    font-family: 'DM Mono', monospace;
    font-size: 0.62rem; letter-spacing: 0.14em; text-transform: uppercase;
    color: var(--text-tertiary);
  }
  .search-input-wrap { position: relative; }
  .search-input {
    width: 100%;
    font-family: 'Montserrat', sans-serif;
    font-weight: 500;
    font-size: 0.92rem;
    color: var(--text-primary);
    background: var(--bg);
    border: 1px solid var(--border-mid);
    border-radius: 4px;
    padding: 0.6rem 0.75rem;
    outline: none;
    transition: border-color 0.15s;
  }
  .search-input:focus { border-color: var(--border-strong); }
  .search-input::placeholder { color: var(--text-tertiary); font-family: 'Source Sans 3', sans-serif; font-style: italic; font-weight: 300; }

  /* Autocomplete dropdown */
  .autocomplete-list {
    position: absolute; top: calc(100% + 4px); left: 0; right: 0;
    background: var(--bg-card);
    border: 1px solid var(--border-mid);
    border-radius: 4px;
    z-index: 50;
    max-height: 220px; overflow-y: auto;
    box-shadow: 0 4px 16px rgba(0,0,0,0.08);
    display: none;
  }
  .autocomplete-list.open { display: block; }
  .autocomplete-item {
    padding: 0.55rem 0.75rem;
    font-size: 0.88rem;
    cursor: pointer;
    display: flex; flex-direction: column; gap: 0.15rem;
    border-bottom: 1px solid var(--border);
    transition: background 0.1s;
  }
  .autocomplete-item:last-child { border-bottom: none; }
  .autocomplete-item:hover, .autocomplete-item.active-item { background: var(--accent-bg); }
  .autocomplete-name { color: var(--text-primary); font-family: 'Montserrat', sans-serif; font-weight: 500; }
  .autocomplete-meta {
    font-family: 'DM Mono', monospace;
    font-size: 0.63rem; letter-spacing: 0.04em;
    color: var(--text-tertiary); text-transform: uppercase;
  }

  .connector-label {
    font-family: 'neue-haas-grotesk-display', sans-serif;
    font-size: 1.4rem; color: var(--text-tertiary);
    text-align: center; padding-bottom: 0.5rem;
    align-self: end;
  }

  .search-btn {
    width: 100%;
    font-family: 'DM Mono', monospace;
    font-size: 0.72rem; letter-spacing: 0.1em; text-transform: uppercase;
    background: var(--text-primary); color: var(--bg);
    border: none; border-radius: 4px;
    padding: 0.65rem 1.25rem;
    cursor: pointer; transition: opacity 0.15s;
  }
  .search-btn:hover { opacity: 0.8; }
  .search-btn:disabled { opacity: 0.3; cursor: default; }

  /* QUICK PAIRS */
  .quick-label {
    font-family: 'DM Mono', monospace;
    font-size: 0.62rem; letter-spacing: 0.12em; text-transform: uppercase;
    color: var(--text-tertiary); margin-bottom: 0.6rem;
  }
  .quick-pairs {
    display: flex; flex-wrap: wrap; gap: 0.5rem;
    margin-bottom: 2.5rem;
  }
  .quick-pair {
    font-family: 'DM Mono', monospace; font-size: 0.72rem;
    letter-spacing: 0.03em;
    border: 1px solid var(--border-mid);
    border-radius: 3px; padding: 0.3rem 0.7rem;
    cursor: pointer; color: var(--text-secondary);
    background: var(--bg-card);
    transition: all 0.15s;
    white-space: nowrap;
  }
  .quick-pair:hover {
    background: var(--accent-bg);
    border-color: var(--border-strong);
    color: var(--text-primary);
  }

  /* RESULT AREA */
  #resultArea { margin-top: 0; }

  /* NO PATH */
  .no-path {
    padding: 2rem;
    background: var(--bg-card);
    border: 1px solid var(--border);
    border-radius: 6px;
    text-align: center;
  }
  .no-path-title {
    font-family: 'neue-haas-grotesk-display', sans-serif;
    font-size: 1.1rem; margin-bottom: 0.5rem;
  }
  .no-path-sub { font-size: 0.88rem; color: var(--text-secondary); }

  /* RESULT CARD */
  .result-card {
    background: var(--bg-card);
    border: 1px solid var(--border-mid);
    border-radius: 6px;
    overflow: hidden;
    animation: fadeUp 0.3s ease;
  }
  @keyframes fadeUp {
    from { opacity: 0; transform: translateY(8px); }
    to   { opacity: 1; transform: translateY(0); }
  }

  /* RESULT HEADER */
  .result-header {
    padding: 1.25rem 1.5rem;
    border-bottom: 1px solid var(--border);
    display: flex; align-items: center; justify-content: space-between;
    gap: 1rem; flex-wrap: wrap;
  }
  .result-headline {
    font-family: 'neue-haas-grotesk-display', sans-serif;
    font-size: 1rem; font-weight: 500;
    letter-spacing: -0.01em;
  }
  .degree-badge {
    font-family: 'DM Mono', monospace;
    font-size: 0.65rem; letter-spacing: 0.1em; text-transform: uppercase;
    padding: 0.25rem 0.65rem; border-radius: 2px;
    white-space: nowrap;
  }
  .degree-badge.deg-1 {
    background: var(--highlight-dim);
    color: var(--highlight);
    border: 1px solid var(--highlight-mid);
  }
  .degree-badge.deg-2 {
    background: rgba(26,26,26,0.05);
    color: var(--text-secondary);
    border: 1px solid var(--border-mid);
  }
  .degree-badge.deg-3 {
    background: var(--bg-secondary);
    color: var(--text-tertiary);
    border: 1px solid var(--border);
  }

  /* PATH VISUALIZATION */
  .path-viz {
    padding: 2rem 1.5rem;
    display: flex;
    flex-direction: column;
    gap: 0;
  }

  /* NODE */
  .path-node {
    display: flex;
    align-items: flex-start;
    gap: 1rem;
  }
  .node-indicator {
    display: flex;
    flex-direction: column;
    align-items: center;
    flex-shrink: 0;
    width: 36px;
  }
  .node-dot {
    width: 36px; height: 36px;
    border-radius: 50%;
    background: var(--node-bg);
    color: var(--node-text);
    display: flex; align-items: center; justify-content: center;
    font-family: 'DM Mono', monospace;
    font-size: 0.65rem; letter-spacing: 0.05em;
    flex-shrink: 0;
    position: relative;
    z-index: 1;
  }
  .node-dot.endpoint {
    background: var(--text-primary);
    box-shadow: 0 0 0 3px var(--bg), 0 0 0 4px var(--text-primary);
  }
  .node-line {
    width: 1px;
    background: var(--border-mid);
    flex: 1;
    min-height: 0;
  }
  .node-content {
    padding-top: 0.4rem;
    padding-bottom: 1.5rem;
    flex: 1;
  }
  .node-name {
    font-family: 'neue-haas-grotesk-display', sans-serif;
    font-size: 1.05rem; font-weight: 500;
    letter-spacing: -0.01em;
    margin-bottom: 0.2rem;
  }
  .node-name a {
    color: inherit; text-decoration: none;
    border-bottom: 1px solid transparent;
    transition: border-color 0.15s;
  }
  .node-name a:hover { border-bottom-color: var(--text-primary); }
  .node-meta {
    font-family: 'DM Mono', monospace;
    font-size: 0.65rem; letter-spacing: 0.07em; text-transform: uppercase;
    color: var(--text-tertiary);
  }

  /* EDGE */
  .path-edge {
    display: flex;
    align-items: flex-start;
    gap: 1rem;
    margin: 0;
  }
  .edge-indicator {
    width: 36px;
    display: flex;
    flex-direction: column;
    align-items: center;
    flex-shrink: 0;
  }
  .edge-line-top, .edge-line-bot {
    width: 1px;
    background: var(--border-mid);
    flex: 1;
    min-height: 10px;
  }
  .edge-icon {
    font-size: 0.55rem;
    color: var(--text-tertiary);
    flex-shrink: 0;
    padding: 2px 0;
  }
  .edge-content {
    padding: 0.5rem 0;
    flex: 1;
  }
  .edge-label {
    display: inline-flex;
    align-items: center;
    gap: 0.5rem;
    font-family: 'DM Mono', monospace;
    font-size: 0.7rem; letter-spacing: 0.05em;
    color: var(--text-secondary);
    background: var(--bg-secondary);
    border: 1px solid var(--border);
    border-radius: 3px;
    padding: 0.3rem 0.65rem;
  }
  .edge-label.flight-edge {
    background: var(--highlight-dim);
    border-color: var(--highlight-mid);
    color: var(--highlight);
  }
  .edge-dot {
    width: 5px; height: 5px;
    border-radius: 50%;
    background: currentColor;
    flex-shrink: 0;
  }
  .edge-detail {
    font-size: 0.8rem;
    color: var(--text-tertiary);
    margin-top: 0.3rem;
    line-height: 1.5;
  }
  .edge-detail a {
    color: var(--text-secondary);
    text-decoration: none;
    border-bottom: 1px solid var(--border-mid);
    transition: color 0.15s, border-color 0.15s;
  }
  .edge-detail a:hover {
    color: var(--text-primary);
    border-color: var(--text-primary);
  }

  /* ALT PATHS */
  .alt-paths {
    border-top: 1px solid var(--border);
    padding: 1.25rem 1.5rem;
  }
  .alt-title {
    font-family: 'DM Mono', monospace;
    font-size: 0.62rem; letter-spacing: 0.12em; text-transform: uppercase;
    color: var(--text-tertiary); margin-bottom: 0.75rem;
  }
  .alt-list { display: flex; flex-direction: column; gap: 0.4rem; }
  .alt-item {
    font-size: 0.85rem;
    color: var(--text-secondary);
    display: flex; align-items: center; gap: 0.5rem;
    cursor: pointer;
    padding: 0.35rem 0.5rem;
    border-radius: 3px;
    transition: background 0.1s;
  }
  .alt-item:hover { background: var(--accent-bg); color: var(--text-primary); }
  .alt-arrow { color: var(--text-tertiary); font-size: 0.7rem; }

  /* CATEGORY COLORS */
  .cat-finance     { color: #2E6F40; }
  .cat-politics    { color: #CC2222; }
  .cat-technology  { color: #000080; }
  .cat-legal       { color: #9A8000; }
  .cat-academia    { color: #6B4226; }
  .cat-entertainment { color: #CC4400; }
  .cat-royalty     { color: #C8909A; }
  .cat-media       { color: #008B87; }
  .cat-other       { color: #888888; }

  [data-theme="dark"] .cat-technology { color: #7777DD; }
  [data-theme="dark"] .cat-legal { color: #D4B800; }

  /* FOOTER */
  .page-footer {
    border-top: 1px solid var(--border-mid);
    padding: 1.5rem 2rem;
    display: flex; align-items: center; justify-content: space-between;
    gap: 1rem; flex-wrap: wrap;
  }
  .footer-note {
    font-family: 'DM Mono', monospace; font-size: 0.65rem;
    letter-spacing: 0.06em; color: var(--text-tertiary);
  }
  .footer-link {
    font-family: 'DM Mono', monospace; font-size: 0.65rem;
    letter-spacing: 0.06em; text-transform: uppercase;
    color: var(--text-tertiary); text-decoration: none;
    border-bottom: 1px solid var(--border-mid);
    transition: color 0.15s, border-color 0.15s;
  }
  .footer-link:hover { color: var(--text-primary); border-color: var(--text-primary); }


  /* Mobile nav drawer */
  .mobile-nav-btn {
    display: none;
    background: none;
    border: 1px solid var(--border-mid);
    border-radius: 4px;
    color: var(--text-tertiary);
    font-size: 1rem;
    width: 30px; height: 30px;
    cursor: pointer;
    align-items: center; justify-content: center;
    flex-shrink: 0;
  }
  .mobile-nav-drawer {
    display: none;
    position: fixed; inset: 0; z-index: 200;
  }
  .mobile-nav-drawer.open { display: block; }
  .mob-overlay {
    position: absolute; inset: 0;
    background: rgba(0,0,0,0.5);
  }
  .mob-panel {
    position: absolute; top: 0; right: 0;
    width: 210px; height: 100%;
    background: var(--bg-card);
    border-left: 1px solid var(--border-mid);
    padding: 1.25rem 1rem;
    display: flex; flex-direction: column;
  }
  .mob-header {
    display: flex; justify-content: space-between; align-items: center;
    margin-bottom: 1.5rem;
  }
  .mob-label {
    font-family: 'DM Mono', monospace;
    font-size: 0.6rem; letter-spacing: 0.14em;
    text-transform: uppercase; color: var(--text-tertiary);
  }
  .mob-close {
    background: none; border: none; cursor: pointer;
    color: var(--text-tertiary); font-size: 1rem;
  }
  .mob-link {
    font-family: 'Montserrat', sans-serif;
    font-weight: 600; font-size: 0.8rem;
    letter-spacing: 0.07em; text-transform: uppercase;
    color: var(--text-secondary); text-decoration: none;
    padding: 0.75rem 0.5rem;
    border-bottom: 1px solid var(--border);
    display: block; transition: color 0.15s;
  }
  .mob-link:hover { color: var(--text-primary); }
  .mob-link.active { color: var(--text-primary); }
  @media (max-width: 640px) {
    .page-wrap { padding: 2rem 1.25rem 4rem; }
    .search-panel { grid-template-columns: 1fr; }
    .connector-label { display: none; }
    .nav-link { font-size: 0.62rem; letter-spacing: 0.04em; padding: 0.3rem 0.45rem; }
  }
  @media (max-width: 520px) {
    .nav-links { display: none; }
    .mobile-nav-btn { display: flex; }
  }
</style>
</head>
<body>

<!-- NAV -->
<nav class="site-nav">
  <a href="index.html" class="topbar-logo-link">
    <div class="topbar-logo">
      <span class="logo-the">The</span>
      <span class="logo-main">Reckoning Radar</span>
    </div>
  </a>
  <button class="mobile-nav-btn" onclick="openMobNav()" aria-label="Menu">☰</button>
  <div class="nav-links">
    <a href="index.html" class="nav-link">Profiles</a>
    <a href="graph.html" class="nav-link">Network</a>
    <a href="redacted.html" class="nav-link">Unidentified</a>
    <a href="connections.html" class="nav-link active">Connections</a>
    <button class="theme-toggle" onclick="toggleTheme()" id="themeBtn">◐</button>
  </div>
</nav>

<div class="page-wrap">

  <!-- HEADER -->
  <h1 class="page-title">How are they connected?</h1>
  <p class="page-subtitle">Find the shortest documented path between any two people in the archive — through shared flights, direct relationships, and documented contacts.</p>

  <!-- SEARCH PANEL -->
  <div class="search-panel">
    <div class="search-field">
      <span class="search-label">Person A</span>
      <div class="search-input-wrap">
        <input class="search-input" id="inputA" placeholder="e.g. Bill Clinton" autocomplete="off" spellcheck="false">
        <div class="autocomplete-list" id="dropA"></div>
      </div>
    </div>

    <div class="connector-label">→</div>

    <div class="search-field">
      <span class="search-label">Person B</span>
      <div class="search-input-wrap">
        <input class="search-input" id="inputB" placeholder="e.g. Kevin Spacey" autocomplete="off" spellcheck="false">
        <div class="autocomplete-list" id="dropB"></div>
      </div>
    </div>
  </div>

  <button class="search-btn" id="findBtn" onclick="findPath()" disabled>Find Connection</button>

  <!-- QUICK PAIRS -->
  <div style="margin-top: 1.5rem;">
    <div class="quick-label">Try these</div>
    <div class="quick-pairs" id="quickPairs">
      <div class="quick-pair" onclick="setQuick('Bill Clinton','Kevin Spacey')">Clinton → Spacey</div>
      <div class="quick-pair" onclick="setQuick('Bill Gates','Ghislaine Maxwell')">Gates → Maxwell</div>
      <div class="quick-pair" onclick="setQuick('Prince Andrew, Duke of York','Virginia Giuffre')">Prince Andrew → Giuffre</div>
      <div class="quick-pair" onclick="setQuick('Larry Summers','Jean-Luc Brunel')">Summers → Brunel</div>
      <div class="quick-pair" onclick="setQuick('Steven Pinker','Bill Clinton')">Pinker → Clinton</div>
      <div class="quick-pair" onclick="setQuick('Alan Dershowitz','Sarah Kellen')">Dershowitz → Kellen</div>
      <div class="quick-pair" onclick="setQuick('Chris Tucker','Ghislaine Maxwell')">Tucker → Maxwell</div>
      <div class="quick-pair" onclick="setQuick('Sarah Ferguson','Prince Andrew, Duke of York')">Ferguson → Andrew</div>
    </div>
  </div>

  <!-- RESULT -->
  <div id="resultArea"></div>

</div>

<!-- FOOTER -->
<footer class="page-footer">
  <span class="footer-note">Connections based on documented flight co-travel and archive relationships</span>
  <a href="index.html" class="footer-link">← All profiles</a>
</footer>

<script>
// ── THEME ──
function getTheme() {
  return localStorage.getItem('rr-theme') ||
    (window.matchMedia('(prefers-color-scheme: dark)').matches ? 'dark' : 'light');
}
function applyTheme(t) {
  document.documentElement.setAttribute('data-theme', t);
  document.getElementById('themeBtn').textContent = t === 'dark' ? '○' : '◐';
}
function toggleTheme() {
  const next = getTheme() === 'dark' ? 'light' : 'dark';
  localStorage.setItem('rr-theme', next);
  applyTheme(next);
}
applyTheme(getTheme());

// ── SUPABASE ──
const SUPABASE_URL = 'https://gljuffkufkggynlaoyim.supabase.co';
const SUPABASE_KEY = 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6ImdsanVmZmt1Zmtnb3lubGFveWltIiwicm9sZSI6ImFub24iLCJpYXQiOjE3NDM5NjU5MDksImV4cCI6MjA1OTU0MTkwOX0.h3Ng3tH-0GVkzDqWxv0yGBDPcj0OyuXYnCQ9NnCHMhY';
const db = supabase.createClient(SUPABASE_URL, SUPABASE_KEY);

// ── STATE ──
let allPersons = [];       // [{id, full_name, category, relationship_to_epstein, power_public_profile}]
let edges = [];            // [{a, b, type, label, detail, flightDate, flightId}]
let adjacency = {};        // {personId: [{personId, edgeIndex}]}
let selectedA = null;
let selectedB = null;

const AIRPORT_NAMES = {
  PBI:'Palm Beach', TEB:'Teterboro', JFK:'New York JFK', HPN:'Westchester',
  EWR:'Newark', MIA:'Miami', TIST:'St. Thomas', LAX:'Los Angeles',
  VNY:'Van Nuys', MRY:'Monterey', CMH:'Columbus OH', ABY:'Albany GA',
  SAF:'Santa Fe', BOS:'Boston', MVY:"Martha's Vineyard", BED:'Bedford MA',
  ASE:'Aspen', IAD:'Washington Dulles', DCA:'Washington National',
  MYNN:'Nassau', MTPP:'Port-au-Prince', TNCM:'St. Maarten',
  RIC:'Richmond VA', HTO:'East Hampton', LAS:'Las Vegas',
  MDW:'Chicago Midway', LFPB:'Paris Le Bourget', MYEF:'Staniel Cay',
  LPAZ:'Santa Cruz Bolivia', GMME:'Rabat Morocco', GMTT:'Tangier Morocco',
  EGBB:'Birmingham UK', EGGW:'London Luton', ESSA:'Stockholm', EIDW:'Dublin',
  LFML:'Marseille', LFMN:'Nice', BGR:'Bangor ME', MBPV:'Turks & Caicos',
};

function routeLabel(origin, dest) {
  const o = AIRPORT_NAMES[origin] || origin;
  const d = AIRPORT_NAMES[dest] || dest;
  return `${o} → ${d}`;
}

function catClass(cat) {
  return cat ? `cat-${cat}` : 'cat-other';
}

// ── LOAD DATA ──
async function loadData() {
  // Persons
  const pRes = await db.from('persons').select('id, full_name, category, relationship_to_epstein, power_public_profile');
  allPersons = pRes.data || [];

  const personMap = {};
  allPersons.forEach(p => personMap[p.id] = p);

  // Flight co-traveler edges
  const fpRes = await db.from('flight_passengers').select('flight_id, person_id, is_identified');
  const fps = fpRes.data || [];

  const fRes = await db.from('flights').select('id, flight_date, origin, destination');
  const flights = fRes.data || [];
  const flightMap = {};
  flights.forEach(f => flightMap[f.id] = f);

  // Group by flight
  const byFlight = {};
  fps.filter(fp => fp.is_identified).forEach(fp => {
    if (!byFlight[fp.flight_id]) byFlight[fp.flight_id] = [];
    byFlight[fp.flight_id].push(fp.person_id);
  });

  // Build pairwise edges from flights
  const flightEdgeMap = {}; // "id1|id2" -> {flights:[...]}
  Object.entries(byFlight).forEach(([fid, pids]) => {
    const f = flightMap[fid];
    if (!f) return;
    for (let i = 0; i < pids.length; i++) {
      for (let j = i + 1; j < pids.length; j++) {
        const key = [pids[i], pids[j]].sort().join('|');
        if (!flightEdgeMap[key]) flightEdgeMap[key] = { flights: [] };
        flightEdgeMap[key].flights.push(f);
      }
    }
  });

  Object.entries(flightEdgeMap).forEach(([key, val]) => {
    const [a, b] = key.split('|');
    if (!personMap[a] || !personMap[b]) return;
    const count = val.flights.length;
    const sorted = val.flights.sort((x,y) => x.flight_date.localeCompare(y.flight_date));
    const first = sorted[0];
    const routes = [...new Set(sorted.map(f => routeLabel(f.origin, f.destination)))];
    const routeStr = routes.slice(0,2).join('; ') + (routes.length > 2 ? ` +${routes.length-2} more` : '');
    edges.push({
      a, b,
      type: 'flight',
      label: count === 1 ? '1 documented flight together' : `${count} documented flights together`,
      detail: `${first.flight_date} · ${routeStr}`,
      weight: count,
    });
  });

  // Direct relationship edges — connect all direct_contact persons to Epstein hub
  // Also add archive-documented relationships from persons table
  const epstein = { id: '__epstein__', full_name: 'Jeffrey Epstein', category: 'other', relationship_to_epstein: 'subject' };

  allPersons.forEach(p => {
    const rel = p.relationship_to_epstein;
    if (!rel || rel === 'mentioned_only') return;

    const relLabels = {
      direct_contact: 'Direct contact — documented in archive',
      employee: 'Employee — documented in archive',
      alleged_client: 'Alleged client — documented in archive',
      victim: 'Documented survivor',
      legal_counsel: 'Legal counsel — documented in archive',
      associate: 'Associate — documented in archive',
    };

    edges.push({
      a: p.id,
      b: '__epstein__',
      type: 'relationship',
      label: relLabels[rel] || 'Documented connection',
      detail: 'Source: Epstein email archive and court records',
      weight: 1,
    });
  });

  // Add Epstein to persons list for pathfinding
  allPersons.push(epstein);
  personMap['__epstein__'] = epstein;

  // Build adjacency list
  allPersons.forEach(p => adjacency[p.id] = []);
  edges.forEach((e, i) => {
    if (adjacency[e.a] && adjacency[e.b]) {
      adjacency[e.a].push({ to: e.b, edgeIdx: i });
      adjacency[e.b].push({ to: e.a, edgeIdx: i });
    }
  });
}

// ── BFS PATHFINDING ──
function bfs(startId, endId) {
  if (startId === endId) return null;

  const visited = new Set([startId]);
  const queue = [{ id: startId, path: [startId], edgePath: [] }];

  while (queue.length > 0) {
    const { id, path, edgePath } = queue.shift();
    const neighbors = adjacency[id] || [];

    for (const { to, edgeIdx } of neighbors) {
      if (visited.has(to)) continue;
      const newPath = [...path, to];
      const newEdgePath = [...edgePath, edgeIdx];

      if (to === endId) {
        return { nodePath: newPath, edgePath: newEdgePath };
      }

      visited.add(to);
      queue.push({ id: to, path: newPath, edgePath: newEdgePath });
    }
  }
  return null; // no path
}

// Find ALL shortest paths (up to 3 alternatives)
function findAllPaths(startId, endId, maxPaths = 3) {
  if (startId === endId) return [];
  const shortest = bfs(startId, endId);
  if (!shortest) return [];

  const targetLen = shortest.nodePath.length;
  const results = [shortest];

  // Try to find alternative paths of same length by blocking edges
  for (let i = 0; i < shortest.edgePath.length && results.length < maxPaths; i++) {
    const blockedEdge = shortest.edgePath[i];
    // Temporarily remove this edge from adjacency
    const edgeData = edges[blockedEdge];
    const adjA = adjacency[edgeData.a];
    const adjB = adjacency[edgeData.b];

    const idxA = adjA.findIndex(x => x.edgeIdx === blockedEdge);
    const idxB = adjB.findIndex(x => x.edgeIdx === blockedEdge);
    if (idxA !== -1) adjA.splice(idxA, 1);
    if (idxB !== -1) adjB.splice(idxB, 1);

    const alt = bfs(startId, endId);
    if (alt && alt.nodePath.length === targetLen) {
      // Check it's genuinely different
      const altKey = alt.nodePath.join('|');
      const exists = results.some(r => r.nodePath.join('|') === altKey);
      if (!exists) results.push(alt);
    }

    // Restore edge
    if (idxA !== -1) adjA.splice(idxA, 0, { to: edgeData.b, edgeIdx: blockedEdge });
    if (idxB !== -1) adjB.splice(idxB, 0, { to: edgeData.a, edgeIdx: blockedEdge });
  }

  return results;
}

// ── RENDER ──
function personMap() {
  const m = {};
  allPersons.forEach(p => m[p.id] = p);
  return m;
}

function renderPath(result, pMap, isAlt = false) {
  const { nodePath, edgePath } = result;
  const degrees = nodePath.length - 1;

  const degClass = degrees === 1 ? 'deg-1' : degrees === 2 ? 'deg-2' : 'deg-3';
  const degLabel = degrees === 1
    ? '1 degree of separation'
    : `${degrees} degrees of separation`;

  const aName = pMap[nodePath[0]]?.full_name || '?';
  const bName = pMap[nodePath[nodePath.length - 1]]?.full_name || '?';

  const headline = degrees === 1
    ? `${aName} and ${bName} are directly connected`
    : `${aName} → ${bName} in ${degrees} steps`;

  let html = `
    <div class="result-card">
      <div class="result-header">
        <span class="result-headline">${headline}</span>
        <span class="degree-badge ${degClass}">${degLabel}</span>
      </div>
      <div class="path-viz">
  `;

  nodePath.forEach((pid, idx) => {
    const person = pMap[pid];
    if (!person) return;
    const isFirst = idx === 0;
    const isLast = idx === nodePath.length - 1;
    const isEndpoint = isFirst || isLast;

    const profileLink = pid === '__epstein__'
      ? `index.html?search=Jeffrey+Epstein`
      : `index.html?search=${encodeURIComponent(person.full_name)}`;

    html += `
      <div class="path-node">
        <div class="node-indicator">
          <div class="node-dot ${isEndpoint ? 'endpoint' : ''}">${isFirst ? 'A' : isLast ? 'B' : idx}</div>
          ${!isLast ? '<div class="node-line" style="min-height:40px;"></div>' : ''}
        </div>
        <div class="node-content">
          <div class="node-name">
            <a href="${profileLink}">${person.full_name}</a>
          </div>
          <div class="node-meta ${catClass(person.category)}">${person.category || 'associate'}</div>
        </div>
      </div>
    `;

    // Edge after this node (except last)
    if (idx < edgePath.length) {
      const edge = edges[edgePath[idx]];
      if (edge) {
        const isFlight = edge.type === 'flight';
        html += `
          <div class="path-edge">
            <div class="edge-indicator">
              <div class="edge-line-top"></div>
              <div class="edge-icon">◆</div>
              <div class="edge-line-bot"></div>
            </div>
            <div class="edge-content">
              <div class="edge-label ${isFlight ? 'flight-edge' : ''}">
                <span class="edge-dot"></span>
                ${edge.label}
              </div>
              <div class="edge-detail">${edge.detail}</div>
            </div>
          </div>
        `;
      }
    }
  });

  html += `</div></div>`;
  return html;
}

function renderResult(paths, pMap) {
  const area = document.getElementById('resultArea');
  if (!paths || paths.length === 0) {
    area.innerHTML = `
      <div class="no-path">
        <div class="no-path-title">No documented connection found</div>
        <div class="no-path-sub">These individuals do not share a documented flight or archive relationship within the current dataset. The connection may exist but hasn't been recorded in available sources.</div>
      </div>
    `;
    return;
  }

  const primary = paths[0];
  const alts = paths.slice(1);

  let html = renderPath(primary, pMap);

  // Alternative paths
  if (alts.length > 0) {
    const degrees = primary.nodePath.length - 1;
    let altHtml = `
      <div class="alt-paths">
        <div class="alt-title">Alternative paths — also ${degrees} degree${degrees !== 1 ? 's' : ''}</div>
        <div class="alt-list">
    `;
    alts.forEach(alt => {
      const midNames = alt.nodePath.slice(1, -1).map(pid => pMap[pid]?.full_name || '?');
      const label = midNames.length === 0
        ? 'Direct connection'
        : `via ${midNames.join(' → ')}`;
      altHtml += `<div class="alt-item"><span class="alt-arrow">↳</span>${label}</div>`;
    });
    altHtml += `</div></div>`;

    // Insert alt paths inside the result card before closing
    html = html.replace('</div></div>', altHtml + '</div></div>');
  }

  area.innerHTML = html;

  // Animate in
  area.querySelector('.result-card').style.animation = 'fadeUp 0.3s ease';
}

// ── AUTOCOMPLETE ──
function setupAutocomplete(inputId, dropId, onSelect) {
  const input = document.getElementById(inputId);
  const drop = document.getElementById(dropId);
  let activeIdx = -1;

  function filter(query) {
    if (!query || query.length < 1) { drop.classList.remove('open'); return; }
    const q = query.toLowerCase();
    const matches = allPersons
      .filter(p => p.id !== '__epstein__' && p.full_name.toLowerCase().includes(q))
      .sort((a, b) => {
        const aStart = a.full_name.toLowerCase().startsWith(q) ? 0 : 1;
        const bStart = b.full_name.toLowerCase().startsWith(q) ? 0 : 1;
        if (aStart !== bStart) return aStart - bStart;
        return (b.power_public_profile || 0) - (a.power_public_profile || 0);
      })
      .slice(0, 8);

    if (matches.length === 0) { drop.classList.remove('open'); return; }

    drop.innerHTML = matches.map((p, i) => `
      <div class="autocomplete-item" data-id="${p.id}" data-name="${p.full_name}" data-idx="${i}">
        <span class="autocomplete-name">${p.full_name}</span>
        <span class="autocomplete-meta ${catClass(p.category)}">${p.category || 'associate'} · ${p.relationship_to_epstein || ''}</span>
      </div>
    `).join('');

    drop.querySelectorAll('.autocomplete-item').forEach(el => {
      el.addEventListener('mousedown', e => {
        e.preventDefault();
        const name = el.dataset.name;
        const id = el.dataset.id;
        input.value = name;
        drop.classList.remove('open');
        onSelect({ id, full_name: name });
      });
    });

    activeIdx = -1;
    drop.classList.add('open');
  }

  input.addEventListener('input', () => filter(input.value));
  input.addEventListener('focus', () => { if (input.value) filter(input.value); });
  input.addEventListener('blur', () => setTimeout(() => drop.classList.remove('open'), 150));

  input.addEventListener('keydown', e => {
    const items = drop.querySelectorAll('.autocomplete-item');
    if (e.key === 'ArrowDown') {
      e.preventDefault();
      activeIdx = Math.min(activeIdx + 1, items.length - 1);
      items.forEach((el, i) => el.classList.toggle('active-item', i === activeIdx));
    } else if (e.key === 'ArrowUp') {
      e.preventDefault();
      activeIdx = Math.max(activeIdx - 1, 0);
      items.forEach((el, i) => el.classList.toggle('active-item', i === activeIdx));
    } else if (e.key === 'Enter' && activeIdx >= 0) {
      e.preventDefault();
      const active = items[activeIdx];
      if (active) {
        input.value = active.dataset.name;
        drop.classList.remove('open');
        onSelect({ id: active.dataset.id, full_name: active.dataset.name });
      }
    } else if (e.key === 'Escape') {
      drop.classList.remove('open');
    }
  });
}

// ── FIND PATH ──
function findPath() {
  if (!selectedA || !selectedB) return;
  if (selectedA.id === selectedB.id) {
    document.getElementById('resultArea').innerHTML = `
      <div class="no-path">
        <div class="no-path-title">Same person selected</div>
        <div class="no-path-sub">Please select two different individuals.</div>
      </div>
    `;
    return;
  }

  const pMap = personMap();
  const paths = findAllPaths(selectedA.id, selectedB.id);
  renderResult(paths, pMap);

  // Scroll to result
  document.getElementById('resultArea').scrollIntoView({ behavior: 'smooth', block: 'start' });
}

// ── QUICK PAIRS ──
function setQuick(nameA, nameB) {
  const a = allPersons.find(p => p.full_name === nameA);
  const b = allPersons.find(p => p.full_name === nameB);
  if (!a || !b) return;

  document.getElementById('inputA').value = nameA;
  document.getElementById('inputB').value = nameB;
  selectedA = a;
  selectedB = b;
  document.getElementById('findBtn').disabled = false;
  findPath();
}

// ── INIT ──
async function init() {
  await loadData();

  setupAutocomplete('inputA', 'dropA', p => {
    selectedA = p;
    document.getElementById('findBtn').disabled = !(selectedA && selectedB);
  });

  setupAutocomplete('inputB', 'dropB', p => {
    selectedB = p;
    document.getElementById('findBtn').disabled = !(selectedA && selectedB);
  });

  // Check for URL params to auto-load a query
  const params = new URLSearchParams(window.location.search);
  const qa = params.get('a');
  const qb = params.get('b');
  if (qa && qb) {
    const a = allPersons.find(p => p.full_name.toLowerCase() === qa.toLowerCase());
    const b = allPersons.find(p => p.full_name.toLowerCase() === qb.toLowerCase());
    if (a && b) {
      document.getElementById('inputA').value = a.full_name;
      document.getElementById('inputB').value = b.full_name;
      selectedA = a;
      selectedB = b;
      document.getElementById('findBtn').disabled = false;
      findPath();
    }
  }
}

init();
</script>

<!-- MOBILE NAV DRAWER -->
<div class="mobile-nav-drawer" id="mobDrawer">
  <div class="mob-overlay" onclick="document.getElementById('mobDrawer').classList.remove('open')"></div>
  <div class="mob-panel">
    <div class="mob-header">
      <span class="mob-label">Navigate</span>
      <button class="mob-close" onclick="document.getElementById('mobDrawer').classList.remove('open')">✕</button>
    </div>
    <a href="index.html" class="mob-link">Profiles</a>
    <a href="graph.html" class="mob-link">Network</a>
    <a href="redacted.html" class="mob-link">Unidentified</a>
    <a href="connections.html" class="mob-link active">Connections</a>
  </div>
</div>
<script>
function openMobNav() { document.getElementById('mobDrawer').classList.add('open'); }
</script>
</body>
</html>
